<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Command Console Pro</title>
    <style>
        /* --- CORE THEME --- */
        :root {
            --bg-color: #0d1117;
            --term-green: #00ff41;
            --term-dim: #008F11;
            --term-highlight: #1f6feb; /* Blue highlight for active reading */
            --ui-border: #30363d;
            --btn-bg: #21262d;
            --btn-active: #238636;
            --btn-danger: #da3633;
        }

        body {
            background-color: var(--bg-color);
            color: var(--term-green);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll, handle in console-output */
        }

        /* --- CONTROL PANEL (Top) --- */
        #controls {
            background: #161b22;
            padding: 10px;
            border-bottom: 1px solid var(--ui-border);
            display: flex;
            flex-direction: column; /* Stacked for mobile */
            gap: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        select {
            background: #0d1117;
            color: var(--term-green);
            border: 1px solid var(--term-dim);
            padding: 12px; /* Larger touch target */
            border-radius: 4px;
            width: 100%;
            font-family: inherit;
            outline: none;
            font-size: 1rem;
        }

        /* Button Row */
        .btn-group {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        button {
            flex: 1; /* Equal width */
            padding: 12px;
            border: 1px solid var(--ui-border);
            border-radius: 6px;
            background: var(--btn-bg);
            color: white;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        button:active { transform: scale(0.96); }
        
        #btn-play { color: var(--term-green); border-color: var(--term-dim); }
        #btn-pause { color: #e3b341; border-color: #e3b341; }
        #btn-stop { color: var(--btn-danger); border-color: var(--btn-danger); }

        /* --- CONSOLE OUTPUT --- */
        #console-output {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            scroll-behavior: smooth;
            padding-bottom: 80px; /* Space for scrolling */
        }

        .log-entry {
            display: flex;
            gap: 10px;
            padding: 10px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
            opacity: 0.7; /* Dim inactive text slightly */
        }

        /* The Active Reading State */
        .log-entry.active-reading {
            opacity: 1;
            background: rgba(31, 111, 235, 0.15); /* Subtle blue glow */
            border-left: 3px solid var(--term-green);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.1);
            border-radius: 0 4px 4px 0;
            transform: scale(1.02); /* Slight pop */
        }

        .timestamp {
            color: var(--term-dim);
            font-size: 0.8em;
            min-width: 70px;
            flex-shrink: 0;
        }

        .message {
            word-break: break-word;
            line-height: 1.5;
        }

        /* --- INPUT AREA (Bottom) --- */
        #input-area {
            background: #161b22;
            padding: 15px;
            border-top: 1px solid var(--ui-border);
            display: flex;
            align-items: center;
        }

        .prompt-char {
            color: var(--term-green);
            margin-right: 10px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        #command-input {
            background: transparent;
            border: none;
            color: white;
            font-family: inherit;
            font-size: 16px;
            flex: 1;
            outline: none;
        }
    </style>
</head>
<body>

    <div id="controls">
        <select id="voice-select">
            <option value="">Loading voices...</option>
        </select>
        <div class="btn-group">
            <button id="btn-play">▶ Play</button>
            <button id="btn-pause">⏸ Pause</button>
            <button id="btn-stop">⏹ Stop</button>
        </div>
    </div>

    <div id="console-output">
        <div class="log-entry">
            <span class="timestamp">[SYS]</span>
            <span class="message">System Ready. Select voice and type below.</span>
        </div>
    </div>

    <div id="input-area">
        <span class="prompt-char">&gt;</span>
        <input type="text" id="command-input" placeholder="Type message..." autocomplete="off">
    </div>

<script>
    // --- ANDROID/WEB SPEECH API LOGIC ---

    const synth = window.speechSynthesis;
    const voiceSelect = document.getElementById('voice-select');
    const inputField = document.getElementById('command-input');
    const outputDiv = document.getElementById('console-output');
    
    // Button References
    const btnPlay = document.getElementById('btn-play');
    const btnPause = document.getElementById('btn-pause');
    const btnStop = document.getElementById('btn-stop');

    let voices = [];
    let currentUtterance = null; 
    let isPaused = false;

    // --- 1. VOICE LOADING (Mobile Optimized) ---
    function populateVoiceList() {
        voices = synth.getVoices();
        voiceSelect.innerHTML = '';

        if(voices.length === 0) {
            let option = document.createElement('option');
            option.textContent = "Waiting for voices...";
            voiceSelect.appendChild(option);
            return;
        }

        // Sort: Local voices usually sound better on mobile
        voices.sort((a, b) => {
            const aName = a.name.toUpperCase();
            const bName = b.name.toUpperCase();
            if (a.lang.startsWith('en') && !b.lang.startsWith('en')) return -1;
            return aName.localeCompare(bName);
        });

        voices.forEach((voice) => {
            const option = document.createElement('option');
            option.textContent = `${voice.name} (${voice.lang})`;
            option.setAttribute('data-name', voice.name);
            voiceSelect.appendChild(option);
        });
    }

    populateVoiceList();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoiceList;
    }

    // --- 2. CORE UTILITIES ---
    
    function createLogEntry(text, source = "USER") {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString([], { hour12: false, hour:'2-digit', minute:'2-digit' });
        
        entry.innerHTML = `
            <span class="timestamp">[${time}]</span>
            <span class="message">${text}</span>
        `;
        
        outputDiv.appendChild(entry);
        // Scroll bottom immediately on creation
        outputDiv.scrollTop = outputDiv.scrollHeight;
        
        return entry; // Return reference for highlighting later
    }

    // --- 3. SPEECH LOGIC WITH HIGHLIGHTING ---

    function speak(text, logElement) {
        // Cancel any current speech before starting new (standard console behavior)
        if (synth.speaking) {
            synth.cancel();
        }

        const utterThis = new SpeechSynthesisUtterance(text);
        
        // Voice Selection
        const selectedName = voiceSelect.selectedOptions[0]?.getAttribute('data-name');
        if (selectedName) {
            const foundVoice = voices.find(v => v.name === selectedName);
            if(foundVoice) utterThis.voice = foundVoice;
        }

        // --- EVENT: START (Highlight & Center) ---
        utterThis.onstart = () => {
            // Remove highlight from all other entries
            document.querySelectorAll('.log-entry').forEach(el => el.classList.remove('active-reading'));
            
            // Highlight current
            logElement.classList.add('active-reading');
            
            // CENTER THE TEXT
            logElement.scrollIntoView({ behavior: "smooth", block: "center" });
            
            isPaused = false;
        };

        // --- EVENT: END (Remove Highlight) ---
        utterThis.onend = () => {
            logElement.classList.remove('active-reading');
            isPaused = false;
        };

        utterThis.onerror = (e) => {
            console.error("Speech Error:", e);
            logElement.classList.remove('active-reading');
            isPaused = false;
        };

        currentUtterance = utterThis;
        synth.speak(utterThis);
    }

    // --- 4. BUTTON CONTROLS ---

    // PLAY / RESUME
    btnPlay.addEventListener('click', () => {
        if (isPaused) {
            synth.resume();
            isPaused = false;
        } else {
            // If nothing is paused, maybe user wants to re-read the last message? 
            // For now, resume is mostly for un-pausing.
            if(synth.paused) synth.resume(); 
        }
    });

    // PAUSE
    btnPause.addEventListener('click', () => {
        if (synth.speaking && !synth.paused) {
            synth.pause();
            isPaused = true;
        }
    });

    // STOP
    btnStop.addEventListener('click', () => {
        if (synth.speaking || synth.paused) {
            synth.cancel();
            isPaused = false;
            // Remove highlights manually since onend might not fire on cancel
            document.querySelectorAll('.log-entry').forEach(el => el.classList.remove('active-reading'));
        }
    });

    // --- 5. INPUT HANDLING ---
    inputField.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const text = inputField.value.trim();
            if(!text) return;

            // 1. Create UI Element
            const logEl = createLogEntry(text);
            
            // 2. Trigger Speak with reference to UI Element
            speak(text, logEl);

            // 3. Reset
            inputField.value = '';
            // Keep focus on mobile requires care, usually better to blur if keyboard hides content, 
            // but for a chat app, keeping focus is standard.
            inputField.focus();
        }
    });

</script>
</body>
</html>