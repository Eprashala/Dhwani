<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no">
    <title>Dhwani AI translator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }

        .chat-scroll { -ms-overflow-style: none; scrollbar-width: none; }
        .chat-scroll::-webkit-scrollbar { display: none; }

        .pulse-ring { animation: pulse-purple 2s infinite; }
        @keyframes pulse-purple {
            0% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(168, 85, 247, 0); }
            100% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0); }
        }

        .glass-header {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-bubble-me {
            background: linear-gradient(135deg, #6d28d9 0%, #7c3aed 100%);
            color: white;
            border-bottom-left-radius: 2px;
        }
        .chat-bubble-guest {
            background: linear-gradient(135deg, #be185d 0%, #db2777 100%);
            color: white;
            border-bottom-right-radius: 2px;
        }
        
        button { user-select: none; -webkit-tap-highlight-color: transparent; touch-action: none; }
    </style>
</head>
<body class="bg-slate-900 h-[100dvh] w-full flex flex-col overflow-hidden text-slate-100">

    <!-- HEADER -->
    <header class="glass-header z-50 shrink-0 px-4 py-3 flex justify-between items-center relative">
        <div class="flex items-center gap-2">
            <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-600 to-pink-600 flex items-center justify-center text-white font-bold text-lg shadow-sm">D</div>
            <div>
                <h1 class="text-lg font-bold text-white leading-tight">Dhwani</h1>
                <p class="text-[10px] text-purple-400 font-medium tracking-wide">AI Translator</p>
            </div>
        </div>
        <button id="api-settings-btn" class="p-2 text-slate-400 hover:text-purple-400 transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.157.92c.447.1.879.255 1.288.452l.85-.386c.52-.236 1.137-.089 1.48.358l.775 1.127c.36.523.275 1.197-.184 1.54l-.768.56c.06.33.097.67.097 1.01 0 .34-.037.68-.097 1.01l.768.56c.459.343.544 1.017.184 1.54l-.775 1.127c-.343.447-.96.594-1.48.358l-.85-.386c-.409.197-.841.352-1.288.452l-.157.92z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>
        
        <div id="api-panel" class="hidden absolute top-full right-0 mt-2 w-64 bg-slate-800 shadow-xl rounded-xl border border-slate-700 p-3 mr-2 z-50">
            <p class="text-xs text-slate-400 mb-2">Translation API Email (Optional):</p>
            <input type="email" id="user-email-input" placeholder="email@example.com" class="w-full text-xs p-2 rounded bg-slate-700 border border-slate-600 text-white mb-2 focus:ring-2 focus:ring-purple-500 outline-none">
            <button id="save-api-btn" class="w-full bg-purple-600 text-white text-xs py-2 rounded font-bold hover:bg-purple-500">Save & Close</button>
        </div>
    </header>

    <!-- LANGUAGE ROW -->
    <div class="bg-slate-800/50 shrink-0 px-4 py-2 border-b border-slate-700 flex gap-3">
        <div class="flex-1">
            <label class="text-[10px] font-bold text-purple-400 uppercase block mb-1">Me</label>
            <select id="lang-me" class="w-full text-sm p-2 rounded-lg border border-slate-600 bg-slate-700 text-white focus:border-purple-500 outline-none shadow-sm"></select>
        </div>
        <div class="flex-1 text-right">
            <label class="text-[10px] font-bold text-pink-400 uppercase block mb-1">Guest</label>
            <select id="lang-guest" class="w-full text-sm p-2 rounded-lg border border-slate-600 bg-slate-700 text-white focus:border-pink-500 outline-none shadow-sm text-right" dir="rtl"></select>
        </div>
    </div>

    <!-- CHAT -->
    <main id="chat-container" class="flex-grow chat-scroll overflow-y-auto px-4 py-4 space-y-4 bg-gradient-to-b from-slate-900 to-slate-800">
        <div id="intro-msg" class="text-center mt-12 opacity-30">
            <div class="w-16 h-16 bg-slate-700 rounded-full mx-auto flex items-center justify-center mb-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                </svg>
            </div>
            <p class="text-sm text-slate-400 font-medium">Hold a button and speak to translate</p>
        </div>
        <div class="h-32 w-full shrink-0"></div>
    </main>

    <!-- STATUS BUBBLE -->
    <div id="status-bar" class="fixed top-24 left-1/2 -translate-x-1/2 z-40 px-4 py-1.5 bg-purple-900/90 backdrop-blur text-white text-xs font-medium rounded-full hidden pointer-events-none border border-purple-500/30">
        Ready.
    </div>

    <!-- FOOTER: PUSH-TO-TALK BUTTONS -->
    <footer class="z-50 shrink-0 w-full bg-slate-900/95 border-t border-slate-800 px-4 pb-5 pt-3">
        <div class="flex gap-4">
            <button id="btn-me" class="flex-1 h-14 rounded-2xl bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-bold text-sm flex items-center justify-center shadow-lg shadow-purple-900/40 active:scale-95 transition-all">
                <span>Me â€“ Hold to Talk</span>
            </button>
            <button id="btn-guest" class="flex-1 h-14 rounded-2xl bg-gradient-to-r from-pink-600 to-rose-600 text-white font-bold text-sm flex items-center justify-center shadow-lg shadow-rose-900/40 active:scale-95 transition-all">
                <span>Guest â€“ Hold to Talk</span>
            </button>
        </div>
        <p class="mt-2 text-[10px] text-slate-500 text-center">Press & hold to record Â· Release to translate & speak</p>
    </footer>

    <script>
        // --- SCREEN WAKE LOCK ---
        let wakeLock = null;
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => console.log('Wake Lock released'));
                }
            } catch (err) { console.error(err); }
        }
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock();
        });
        window.onload = requestWakeLock;

        // --- LANGUAGES ---
        const LANGUAGES = [
            { code: 'en-IN', name: 'English (India)' },
            { code: 'hi-IN', name: 'Hindi (à¤¹à¤¿à¤‚à¤¦à¥€)' },
            { code: 'mr-IN', name: 'Marathi (à¤®à¤°à¤¾à¤ à¥€)' },
            { code: 'gu-IN', name: 'Gujarati (àª—à«àªœàª°àª¾àª¤à«€)' },
            { code: 'ta-IN', name: 'Tamil (à®¤à®®à®¿à®´à¯)' },
            { code: 'te-IN', name: 'Telugu (à°¤à±†à°²à±à°—à±)' },
            { code: 'bn-IN', name: 'Bengali (à¦¬à¦¾à¦‚à¦²à¦¾)' },
            { code: 'kn-IN', name: 'Kannada (à²•à²¨à³à²¨à²¡)' },
            { code: 'ml-IN', name: 'Malayalam (à´®à´²à´¯à´¾à´³à´‚)' },
            { code: 'pa-IN', name: 'Punjabi (à¨ªà©°à¨œà¨¾à¨¬à©€)' },
            { code: 'ur-IN', name: 'Urdu (Ø§Ø±Ø¯Ùˆ)' },
            { code: 'or-IN', name: 'Odia (à¬“à¬¡à¬¼à¬¿à¬†)' },
            { code: 'as-IN', name: 'Assamese (à¦…à¦¸à¦®à§€à¦¯à¦¼à¦¾)' },
            { code: 'en-US', name: 'English (Global)' },
            { code: 'zh-CN', name: 'Chinese (Mandarin)' },
            { code: 'ja-JP', name: 'Japanese (æ—¥æœ¬èªž)' },
            { code: 'ko-KR', name: 'Korean (í•œêµ­ì–´)' },
            { code: 'th-TH', name: 'Thai (à¹„à¸—à¸¢)' },
            { code: 'ms-MY', name: 'Malay (Malaysia)' },
            { code: 'id-ID', name: 'Indonesian' },
            { code: 'vi-VN', name: 'Vietnamese' },
            { code: 'es-ES', name: 'Spanish' },
            { code: 'fr-FR', name: 'French' },
            { code: 'de-DE', name: 'German' },
            { code: 'it-IT', name: 'Italian' },
            { code: 'pt-PT', name: 'Portuguese' },
            { code: 'ru-RU', name: 'Russian' },
            { code: 'ar-SA', name: 'Arabic' }
        ];

        // --- DOM ---
        const chatContainer = document.getElementById('chat-container');
        const introMsg = document.getElementById('intro-msg');
        const statusBar = document.getElementById('status-bar');
        const langMeSelect = document.getElementById('lang-me');
        const langGuestSelect = document.getElementById('lang-guest');
        const btnMe = document.getElementById('btn-me');
        const btnGuest = document.getElementById('btn-guest');
        const apiPanel = document.getElementById('api-panel');
        const apiSettingsBtn = document.getElementById('api-settings-btn');
        const userEmailInput = document.getElementById('user-email-input');
        const saveApiBtn = document.getElementById('save-api-btn');

        // --- STATE ---
        let USER_EMAIL = "";
        let state = 'IDLE'; // IDLE | LISTENING_ME | LISTENING_GUEST | PROCESSING | SPEAKING
        let activeSpeaker = null; // 'ME' or 'GUEST'
        let lastSpeaker = null;   // who just spoke
        let recognition = null;
        let synth = window.speechSynthesis;
        let availableVoices = [];

        let finalTranscript = '';        // concatenation of all final segments
        let currentFullTranscript = '';  // final + latest interim
        let liveMessage = null;          // { speaker, originalNode, translationNode, container }
        let lastTranslatedText = "";
        let lastTranslatedLang = "";
        let currentTranslationId = 0;
        let currentAbortController = null;

        // why did we stop recognition?
        // 'USER_RELEASE' -> send for translation
        // 'SPEAKING'     -> we stopped because TTS needs silence
        // 'OTHER'        -> errors, manual, etc.
        let stopReason = null;

        // preload voices
        if (synth) {
            const loadVoices = () => {
                availableVoices = synth.getVoices();
            };
            synth.onvoiceschanged = loadVoices;
            loadVoices();
        }

        function init() {
            LANGUAGES.forEach(l => {
                langMeSelect.add(new Option(l.name, l.code));
                langGuestSelect.add(new Option(l.name, l.code));
            });
            langMeSelect.value = 'en-IN';
            langGuestSelect.value = 'hi-IN';

            const savedEmail = localStorage.getItem('dhwani_email');
            if (savedEmail) {
                USER_EMAIL = savedEmail;
                userEmailInput.value = savedEmail;
            }

            recognition = setupRecognition();
        }

        // --- SPEECH RECOGNITION ---
        function setupRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateStatus("Speech recognition not supported on this device.", true);
                btnMe.disabled = true;
                btnGuest.disabled = true;
                return null;
            }
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const rec = new SpeechRecognition();
            rec.continuous = true;       // let it keep listening while button is held
            rec.interimResults = true;

            rec.onstart = () => {
                if (state === 'LISTENING_ME') {
                    updateStatus("Listening (Me)...", false);
                } else if (state === 'LISTENING_GUEST') {
                    updateStatus("Listening (Guest)...", false);
                }
                requestWakeLock();
            };

            rec.onresult = (event) => {
                // accumulate all final results for this press
                finalTranscript = '';
                for (let i = 0; i < event.results.length; i++) {
                    const res = event.results[i];
                    if (res.isFinal) {
                        finalTranscript += res[0].transcript + ' ';
                    }
                }
                finalTranscript = finalTranscript.trim();

                const lastRes = event.results[event.results.length - 1];
                const interim = !lastRes.isFinal ? lastRes[0].transcript : '';
                currentFullTranscript = (finalTranscript + ' ' + interim).trim();

                if (liveMessage && liveMessage.originalNode) {
                    liveMessage.originalNode.textContent = currentFullTranscript || '...';
                }

                updateStatus("Hearing: " + lastRes[0].transcript.slice(-40), false);
            };

            rec.onend = () => {
                // Called after we call recognition.stop()
                // Decide based on stopReason
                if (stopReason === 'USER_RELEASE' && lastSpeaker) {
                    const text = (finalTranscript || currentFullTranscript).trim();
                    finalTranscript = '';
                    currentFullTranscript = '';
                    const speaker = lastSpeaker;
                    stopReason = null;
                    state = 'IDLE';

                    if (!text) {
                        updateStatus("No speech captured.", true);
                        return;
                    }
                    processTranslation(text, speaker);
                } else {
                    // generic stop (e.g. speaking, error)
                    if (state === 'LISTENING_ME' || state === 'LISTENING_GUEST') {
                        state = 'IDLE';
                        updateStatus("Mic stopped.", true);
                    }
                    stopReason = null;
                }
            };

            rec.onerror = (e) => {
                if (e.error === 'not-allowed') {
                    state = 'IDLE';
                    stopReason = 'OTHER';
                    alert("Microphone permission denied.");
                } else {
                    stopReason = 'OTHER';
                    updateStatus("Speech error: " + e.error, true);
                }
            };

            return rec;
        }

        // --- TRANSLATION + TTS ---
        async function fetchMyMemory(text, s, t, signal) {
            const pair = `${s}|${t}`;
            let url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${pair}`;
            if (USER_EMAIL) url += `&de=${encodeURIComponent(USER_EMAIL)}`;
            const res = await fetch(url, { signal });
            const data = await res.json();
            if (data.responseStatus === 200 || data.responseStatus === '200') {
                return data.responseData.translatedText;
            }
            throw new Error(data.responseDetails || "Translation error");
        }

        function speak(text, lang, cb) {
            if (!synth) {
                if (cb) cb();
                return;
            }

            if (synth.speaking) synth.cancel();

            // ðŸ”‡ ensure we don't accidentally trigger onend->translation
            if (recognition && (state === 'LISTENING_ME' || state === 'LISTENING_GUEST')) {
                stopReason = 'SPEAKING';
                try { recognition.stop(); } catch (e) {}
            }

            state = 'SPEAKING';
            updateStatus("Speaking...", false);

            const ut = new SpeechSynthesisUtterance(text);
            ut.lang = lang;
            ut.rate = 0.95;

            const baseLang = lang.split('-')[0];
            let v = availableVoices.find(v => v.lang === lang);
            if (!v) v = availableVoices.find(v => v.lang.startsWith(baseLang));
            if (v) ut.voice = v;

            ut.onend = () => {
                state = 'IDLE';
                if (cb) cb();
            };
            ut.onerror = () => {
                state = 'IDLE';
                if (cb) cb();
            };

            synth.speak(ut);
        }

        async function processTranslation(text, speaker) {
            state = 'PROCESSING';
            updateStatus("Translating...", false);
            introMsg.classList.add('hidden');

            const isMe = speaker === 'ME';
            const sourceLang = isMe ? langMeSelect.value : langGuestSelect.value;
            const targetLang = isMe ? langGuestSelect.value : langMeSelect.value;

            // ensure bubble exists
            if (!liveMessage || liveMessage.speaker !== speaker) {
                liveMessage = addMessage(speaker, text, "...");
            } else {
                if (liveMessage.originalNode) liveMessage.originalNode.textContent = text;
                if (liveMessage.translationNode) liveMessage.translationNode.textContent = "...";
            }

            const myId = ++currentTranslationId;
            if (currentAbortController) currentAbortController.abort();
            currentAbortController = new AbortController();

            try {
                const translated = await fetchMyMemory(text, sourceLang, targetLang, currentAbortController.signal);
                if (myId !== currentTranslationId) return;

                updateLastMessage(translated);
                lastTranslatedText = translated;
                lastTranslatedLang = targetLang;

                // speak translation; mic is muted in speak()
                speak(translated, targetLang, () => {
                    updateStatus("Ready. Hold a button to speak.", true);
                });
            } catch (err) {
                if (err.name === 'AbortError') return;
                updateLastMessage("[Error] " + err.message);
                updateStatus("Translation failed.", true);
            } finally {
                state = 'IDLE';
            }
        }

        // --- UI HELPERS ---
        function addMessage(speaker, text, trans) {
            const isMe = speaker === 'ME';
            const div = document.createElement('div');
            div.className = `flex flex-col max-w-[85%] ${isMe ? 'mr-auto items-start' : 'ml-auto items-end'}`;
            div.innerHTML = `
                <div class="p-3 shadow-sm relative ${isMe ? 'chat-bubble-me' : 'chat-bubble-guest'}">
                    <div class="original-text font-medium text-[15px] leading-snug">${text}</div>
                    <div class="translation-text text-sm opacity-90 italic mt-1 pt-1 border-t border-white/20">${trans}</div>
                </div>
                <span class="text-[10px] text-slate-500 mt-1 px-1 font-bold tracking-wide">${isMe ? 'Me' : 'Guest'}</span>
            `;
            const target = chatContainer.lastElementChild;
            if (target) chatContainer.insertBefore(div, target);
            else chatContainer.appendChild(div);

            const originalNode = div.querySelector('.original-text');
            const translationNode = div.querySelector('.translation-text');
            window.lastTransNode = translationNode;
            chatContainer.scrollTop = chatContainer.scrollHeight;

            liveMessage = { speaker, originalNode, translationNode, container: div };
            return liveMessage;
        }

        function updateLastMessage(text) {
            if (liveMessage && liveMessage.translationNode) {
                liveMessage.translationNode.innerText = text;
            } else if (window.lastTransNode) {
                window.lastTransNode.innerText = text;
            }
        }

        function updateStatus(msg, hide) {
            statusBar.innerText = msg;
            statusBar.classList.remove('hidden');
            if (hide) {
                setTimeout(() => statusBar.classList.add('hidden'), 2000);
            }
        }

        function startListening(speaker) {
            if (!recognition) {
                updateStatus("Speech recognition not available.", true);
                return;
            }
            if (state === 'PROCESSING' || state === 'SPEAKING') {
                // ignore presses while busy
                return;
            }

            if (synth && synth.speaking) synth.cancel();

            activeSpeaker = speaker;
            lastSpeaker = speaker;
            state = speaker === 'ME' ? 'LISTENING_ME' : 'LISTENING_GUEST';
            finalTranscript = '';
            currentFullTranscript = '';
            stopReason = null;

            const langCode = speaker === 'ME' ? langMeSelect.value : langGuestSelect.value;
            recognition.lang = langCode;

            liveMessage = addMessage(speaker, '...', '...');
            if (speaker === 'ME') {
                langMeSelect.parentElement.classList.add('pulse-ring');
                langGuestSelect.parentElement.classList.remove('pulse-ring');
            } else {
                langMeSelect.parentElement.classList.remove('pulse-ring');
                langGuestSelect.parentElement.classList.add('pulse-ring');
            }

            try { recognition.start(); } catch (e) {
                console.error(e);
            }
        }

        function stopListeningAndQueueTranslation() {
            if (!(state === 'LISTENING_ME' || state === 'LISTENING_GUEST')) return;

            // mark that this stop is because user released button
            stopReason = 'USER_RELEASE';

            if (recognition) {
                try { recognition.stop(); } catch (e) {}
            }

            langMeSelect.parentElement.classList.remove('pulse-ring');
            langGuestSelect.parentElement.classList.remove('pulse-ring');

            // actual processTranslation will be called from recognition.onend
        }

        // --- BUTTON EVENTS (PUSH-TO-TALK) ---
        function attachPushToTalk(btn, speaker) {
            btn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                startListening(speaker);
            });
            btn.addEventListener('pointerup', (e) => {
                e.preventDefault();
                stopListeningAndQueueTranslation();
            });
            btn.addEventListener('pointerleave', (e) => {
                if (state === 'LISTENING_ME' || state === 'LISTENING_GUEST') {
                    stopListeningAndQueueTranslation();
                }
            });
            btn.addEventListener('pointercancel', (e) => {
                if (state === 'LISTENING_ME' || state === 'LISTENING_GUEST') {
                    stopListeningAndQueueTranslation();
                }
            });
        }

        // --- API SETTINGS EVENTS ---
        apiSettingsBtn.onclick = () => apiPanel.classList.toggle('hidden');
        saveApiBtn.onclick = () => {
            const val = userEmailInput.value.trim();
            if (val) {
                USER_EMAIL = val;
                localStorage.setItem('dhwani_email', val);
            }
            apiPanel.classList.add('hidden');
            updateStatus("API email saved.", true);
        };

        // --- INIT ---
        attachPushToTalk(btnMe, 'ME');
        attachPushToTalk(btnGuest, 'GUEST');
        init();
    </script>
</body>
</html>
