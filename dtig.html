<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two-User Live STT + Translate (Android-safe)</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 18px; background:#f6f7fb; color:#111; }
    .container { max-width:900px; margin:0 auto; }
    h1 { margin-bottom: 8px; font-size:20px; }
    .controls { display:flex; gap:8px; margin-bottom:12px; align-items:center; flex-wrap:wrap; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:white; cursor:pointer; }
    button.primary { background:#0044cc; color:white; border-color:#0033aa; }
    .users { display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:8px; }
    .card { background:white; padding:12px; border-radius:10px; box-shadow:0 1px 4px rgba(0,0,0,.06); }
    .label { font-weight:700; margin-bottom:6px; }
    .live { min-height:48px; border-radius:6px; padding:8px; background:#f2f6ff; }
    .status { margin-top:6px; font-size:12px; color:#666; }
    .translated { margin-top:8px; padding:8px; background:#fff3f0; border-radius:6px; min-height:40px; }
    .small { font-size:13px; color:#555; }
    select { padding:6px; border-radius:6px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Two-User Live STT + Translate — Android-safe</h1>

    <div class="controls">
      <div>
        <label class="small">Active speaker:</label>
        <button id="u1Btn" class="primary">User 1 (EN)</button>
        <button id="u2Btn">User 2 (HI)</button>
      </div>

      <div>
        <label class="small">User 1 lang</label>
        <select id="lang1">
          <option value="en-US">English (en-US)</option>
          <option value="mr-IN">Marathi (mr-IN)</option>
        </select>
      </div>

      <div>
        <label class="small">User 2 lang</label>
        <select id="lang2">
          <option value="hi-IN">Hindi (hi-IN)</option>
          <option value="en-US">English (en-US)</option>
        </select>
      </div>

      <div>
        <button id="startBtn">Start</button>
        <button id="stopBtn">Stop</button>
      </div>

      <div class="small" style="margin-left:auto">
        <strong>Note:</strong> Use Chrome on Android. Allow microphone when prompted.
      </div>
    </div>

    <div class="users">
      <div class="card">
        <div class="label">USER 1</div>
        <div id="u1Live" class="live">—</div>
        <div id="u1Status" class="status">idle</div>
        <div class="label" style="margin-top:8px;">USER 2 (TRANS)</div>
        <div id="u1Trans" class="translated">—</div>
      </div>

      <div class="card">
        <div class="label">USER 2</div>
        <div id="u2Live" class="live">—</div>
        <div id="u2Status" class="status">idle</div>
        <div class="label" style="margin-top:8px;">USER 1 (TRANS)</div>
        <div id="u2Trans" class="translated">—</div>
      </div>
    </div>
  </div>

  <script>
  // ---------- Configuration ----------
  const els = {
    u1Btn: document.getElementById('u1Btn'),
    u2Btn: document.getElementById('u2Btn'),
    startBtn: document.getElementById('startBtn'),
    stopBtn: document.getElementById('stopBtn'),
    lang1: document.getElementById('lang1'),
    lang2: document.getElementById('lang2'),
    u1Live: document.getElementById('u1Live'),
    u1Status: document.getElementById('u1Status'),
    u1Trans: document.getElementById('u1Trans'),
    u2Live: document.getElementById('u2Live'),
    u2Status: document.getElementById('u2Status'),
    u2Trans: document.getElementById('u2Trans')
  };

  // ---------- State ----------
  let activeTurn = 1; // 1 or 2
  let recognition = null;
  let finalTranscript = "";
  let interimTranscript = "";
  let silenceTimer = null;

  // ---------- Turn UI ----------
  function setActiveTurn(n) {
    activeTurn = n;
    if (n === 1) {
      els.u1Btn.classList.add('primary');
      els.u2Btn.classList.remove('primary');
    } else {
      els.u2Btn.classList.add('primary');
      els.u1Btn.classList.remove('primary');
    }
    // clear display buffers for neatness when switching
    finalTranscript = "";
    interimTranscript = "";
    updateDisplays();
    updateStatus('idle');
  }

  els.u1Btn.onclick = () => setActiveTurn(1);
  els.u2Btn.onclick = () => setActiveTurn(2);

  // ---------- Status / displays ----------
  function updateDisplays() {
    const text = (finalTranscript + interimTranscript).trim();
    if (activeTurn === 1) {
      els.u1Live.textContent = text || '—';
    } else {
      els.u2Live.textContent = text || '—';
    }
  }
  function updateStatus(s) {
    if (activeTurn === 1) {
      els.u1Status.textContent = s;
    } else {
      els.u2Status.textContent = s;
    }
  }

  // ---------- Silence watcher ----------
  function resetSilenceWatcher() {
    if (silenceTimer) clearTimeout(silenceTimer);
    // when user is silent for 1500ms, consider the phrase finished and translate
    silenceTimer = setTimeout(() => {
      processCompletedUtterance();
    }, 1500);
  }

  // ---------- Process completed phrase ----------
  async function processCompletedUtterance() {
    if (!finalTranscript.trim() && !interimTranscript.trim()) return;
    const text = (finalTranscript + interimTranscript).trim();

    // show "final" quickly
    if (activeTurn === 1) {
      els.u1Live.textContent = text;
      els.u1Status.textContent = "HEARD — translating...";
    } else {
      els.u2Live.textContent = text;
      els.u2Status.textContent = "HEARD — translating...";
    }

    // Get translation target languages
    const fromLang = activeTurn === 1 ? els.lang1.value.split('-')[0] : els.lang2.value.split('-')[0];
    const toLang = activeTurn === 1 ? els.lang2.value.split('-')[0] : els.lang1.value.split('-')[0];

    // Translate using MyMemory (simple free endpoint)
    try {
      const translated = await translateText(text, fromLang, toLang);
      if (activeTurn === 1) {
        els.u1Trans.textContent = translated || '—';
        els.u1Status.textContent = "TRANSLATED";
      } else {
        els.u2Trans.textContent = translated || '—';
        els.u2Status.textContent = "TRANSLATED";
      }
    } catch (e) {
      if (activeTurn === 1) {
        els.u1Trans.textContent = "Translation error";
        els.u1Status.textContent = "ERROR";
      } else {
        els.u2Trans.textContent = "Translation error";
        els.u2Status.textContent = "ERROR";
      }
      console.error('translate error', e);
    }

    // Clear transcripts to avoid re-processing same text
    finalTranscript = "";
    interimTranscript = "";
    updateDisplays();
  }

  // ---------- Translation function (MyMemory) ----------
  // Note: free endpoint, limited usage. Consider using a paid translate API for production.
  async function translateText(text, from, to) {
    if (!text) return "";
    const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('Network error');
    const data = await resp.json();
    // MyMemory returns translatedText in data.responseData.translatedText
    let translated = data && data.responseData && data.responseData.translatedText ? data.responseData.translatedText : "";
    // fallback: if there's a match in the matches array with better quality
    if ((!translated || translated.trim() === "") && Array.isArray(data.matches)) {
      const best = data.matches.find(m => m.id === 0) || data.matches[0];
      translated = best ? best.translation : translated;
    }
    return translated;
  }

  // ---------- Build recognition (Android-friendly) ----------
  function buildRecognition() {
    // Check browser support
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert('SpeechRecognition not supported in this browser. Use Chrome on Android/Desktop.');
      return null;
    }

    const r = new SpeechRecognition();
    r.interimResults = true;
    r.continuous = true; // keep listening
    r.maxAlternatives = 1;

    // set initial language
    r.lang = (activeTurn === 1 ? els.lang1.value : els.lang2.value) || 'en-US';

    // Crucial fix: rebuild finalTranscript each time from event.results
    r.onresult = (event) => {
      resetSilenceWatcher();

      // Rebuild transcripts from entire results array instead of appending.
      let rebuiltFinal = "";
      let interim = "";

      for (let i = 0; i < event.results.length; ++i) {
        const res = event.results[i];
        if (res.isFinal) {
          rebuiltFinal += res[0].transcript + " ";
        } else {
          interim += res[0].transcript;
        }
      }

      finalTranscript = rebuiltFinal.trim();
      interimTranscript = interim.trim();

      // Update UI
      updateDisplays();
      updateStatus('HEARING...');
    };

    r.onerror = (ev) => {
      console.warn('recognition error', ev);
      updateStatus('ERROR: ' + (ev.error || ev.type));
      // If 'no-speech' or 'not-allowed' happen, stop recognition gracefully
      if (ev.error === 'not-allowed' || ev.error === 'service-not-allowed') {
        stopRecognition();
      }
    };

    r.onend = () => {
      // auto-restart unless explicitly stopped by user
      // keep short delay to avoid tight restarts
      if (recognition) {
        // restart with current turn's language (helps Android keep correct lang)
        setTimeout(() => {
          try {
            recognition.lang = (activeTurn === 1 ? els.lang1.value : els.lang2.value) || 'en-US';
            recognition.start();
          } catch (e) {
            console.warn('restart failed', e);
          }
        }, 200);
      } else {
        updateStatus('stopped');
      }
    };

    r.onstart = () => {
      updateStatus('listening...');
    };

    return r;
  }

  // ---------- Control start / stop ----------
  function startRecognition() {
    if (recognition) return;
    recognition = buildRecognition();
    if (!recognition) return;
    finalTranscript = "";
    interimTranscript = "";
    try {
      recognition.start();
    } catch (e) {
      // some browsers will throw if start is called twice quickly
      console.warn('start error', e);
    }
  }

  function stopRecognition() {
    if (!recognition) return;
    recognition.onresult = null;
    recognition.onend = null;
    recognition.onerror = null;
    try {
      recognition.stop();
    } catch (e) {
      console.warn('stop failed', e);
    }
    recognition = null;
    if (silenceTimer) { clearTimeout(silenceTimer); silenceTimer = null; }
    finalTranscript = "";
    interimTranscript = "";
    updateStatus('stopped');
  }

  els.startBtn.onclick = () => {
    setActiveTurn(activeTurn); // ensure UI updated
    startRecognition();
  };
  els.stopBtn.onclick = () => {
    stopRecognition();
  };

  // when user changes language while running, update recognition.lang
  els.lang1.onchange = els.lang2.onchange = () => {
    if (recognition) {
      try {
        recognition.lang = (activeTurn === 1 ? els.lang1.value : els.lang2.value);
      } catch (e) { /* ignore */ }
    }
  };

  // On page load, set defaults
  setActiveTurn(1);

  // Optional: allow clicking the live area to force process (handy during tests)
  els.u1Live.onclick = () => { if (activeTurn === 1) processCompletedUtterance(); };
  els.u2Live.onclick = () => { if (activeTurn === 2) processCompletedUtterance(); };

  // Safety: before unload, stop recognition
  window.addEventListener('beforeunload', () => {
    stopRecognition();
  });
  </script>
</body>
</html>
